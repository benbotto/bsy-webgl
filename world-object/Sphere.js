(function(bsy) {
  'use strict';

  /** A sphere. */
  class Sphere extends bsy.WorldObject {
    /**
     * Initialize the sphere.
     */
    constructor(numTriangleStrips = 32) {
      super();

      if (numTriangleStrips % 2 !== 0)
        throw new Error('numTriangleStrips must be even.');

      this.numTriangleStrips = numTriangleStrips;
      this.vertices          = [];

      // Build a single quater dome and put the result in this.vertices.
      const qdVerts = this.buildQuarterDome(numTriangleStrips / 2);

      // Build the sphere out of 8 quarter domes.  The first 4 quarter domes are
      // rotated about the Y axis.  The second 4 are rotated about the Z axis
      // and the Y axis.
      const yAxis = vec3.fromValues(0.0, 1.0, 0.0);
      const zAxis = vec3.fromValues(0.0, 0.0, 1.0);

      for (let dome = 0; dome < 2; ++dome) {
        const rotationZ = mat4.fromRotation(mat4.create(), Math.PI * dome, zAxis);

        for (let i = 0; i < 4; ++i) {
          const rotationY = mat4.fromRotation(mat4.create(), Math.PI / 2 * i, yAxis);

          this.vertices.push(...qdVerts.map(v =>
            vec3.transformMat4(vec3.create(),
              vec3.transformMat4(vec3.create(), v, rotationZ), rotationY)));
        }
      }

      // Flatten the verts into one big array.
      this.vertices = this.vertices.reduce(
        (prev, cur) => prev.concat([cur[0], cur[1], cur[2]]),
        []);
    }

    /**
     * Build a quarter dome.
     */
    buildQuarterDome(numTriangleStrips = 16) {
      const zAxis     = vec3.fromValues(0.0, 0.0, 1.0);
      const yAxis     = vec3.fromValues(0.0, 1.0, 0.0);
      const start     = vec3.fromValues(0.0, 1.0, 0.0);
      const halfPI    = Math.PI / 2;
      const vertices  = [];
      const holdVerts = [];

      /* 
       * This works by generating a large triangle composed of numTriangleStrips
       * number of triangle strips.  A "large triangle" with numTriangleStrips = 2
       * would look like this.
       *
       *          /\
       *         /__\
       *        /\  /\
       *       /__\/__\
       * 
       * The vertices are generated by starting at point 0,1,0, and rotating
       * 90 degrees around the z axis numTriangleStrips + 1 times.  For each
       * iteration, vertices are generated by rotating 90 degrees about the y
       * axis.
       */
      for (let level = 0; level < numTriangleStrips + 1; ++level) {
        const angleZ         = halfPI / numTriangleStrips * level;
        const rotationZ      = mat4.fromRotation(mat4.create(), angleZ, zAxis);
        const vertsThisLevel = level + 1;
        const levelVerts     = [];

        for (let v = 0; v < vertsThisLevel; ++v) {
          const angleY    = (vertsThisLevel === 1) ? 0 : halfPI / (vertsThisLevel - 1) * v;
          const rotationY = mat4.fromRotation(mat4.create(), angleY, yAxis);

          // "start" is rotated about Z then about Y.
          levelVerts.push(
            vec3.transformMat4(vec3.create(),
              vec3.transformMat4(vec3.create(), start, rotationZ), rotationY));
        }

        holdVerts.push(levelVerts);
      }

      /* From the vertices generated above, create a series of triangles that
       * can be used to draw the quarter dome.
       *
       *               |Level|Triangles
       *               |-----|---------
       *       0       |  0  |
       *      / \      |     |
       *     0---1     |  1  | [0,1,0 UP]
       *    / \ / \    |     |
       *   0---1---2   |  2  | [0,1,0 UP] [1,2,1 UP] [0,1,1 DOWN]
       *  / \ / \ / \  |     |
       * 0---1---2---3 |  3  | [0,1,0 UP] [1,2,1 UP] [2,3,2 UP] [0,1,1 DOWN] [1,2,2 DOWN]
       *
       */
      for (let level = 1; level < holdVerts.length; ++level) {
        const numUp   = level;
        const numDown = level - 1;

        // The vertices are pushed clockwise for vertex normal computation.
        for (let u = 0; u < numUp; ++u) {
          vertices.push(holdVerts[level][u]);
          vertices.push(holdVerts[level - 1][u]);
          vertices.push(holdVerts[level][u + 1]);
        }

        for (let d = 0; d < numDown; ++d) {
          vertices.push(holdVerts[level - 1][d]);
          vertices.push(holdVerts[level - 1][d + 1]);
          vertices.push(holdVerts[level][d + 1]);
        }
      }

      return vertices;
    }

    /**
     * Get the vertices.
     */
    getVertices() {
      return this.vertices;
    }
  }

  bsy.Sphere = Sphere;
})(window.bsy);

